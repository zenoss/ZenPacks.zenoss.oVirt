<?xml version="1.0" encoding="utf-8"?>
<configure
    xmlns="http://namespaces.zope.org/zope"
    xmlns:browser="http://namespaces.zope.org/browser"
    xmlns:zcml="http://namespaces.zope.org/zcml">


    <!-- Includes: Browser Configuration -->
    <include package=".browser"/>


    <!-- DataSource  -->

    <adapter
        provides=".interfaces.IOVirtDataSourceInfo"
        for=".datasources.OVirtDataSource.OVirtDataSource"
        factory=".info.OVirtDataSourceInfo"
        />


    <!-- Event Plugins

    These are useful when you want to manipulate events in a more bullet-proof
    way than standard transforms allow. Users won't be able to change your
    plugin code through the user interface like they could with transforms. You
    can also more easily unit test these plugins than you can test transforms.

    You can either register a preEventPlugin or a postEventPlugin.
    preEventPlugins will be executed before any event processing is done. This
    means that no tagging or enrichment of the event will be done. This is a
    useful approach for early-dropping events you don't want to waste time
    processing.

    postEventPlugins will be executed after all normal event processing is
    done. This is useful in circumstances where you need access to the tags and
    other enrichment done during normal event processing in your plugin.

    Using zcml:condition="have eventPlugins" will cause your plugins only to be
    registered if the installed Zenoss versions supports them. Support
    for eventPlugins was added in Zenoss 4.

    See events.py for the plugin implementations.

    <configure zcml:condition="have eventPlugins">
        <preEventPlugin plugin=".events.ExamplePreEventPlugin">
        <postEventPlugin plugin=".events.ExamplePostEventPlugin">
    </configure>
    -->


    <include zcml:condition="installed ZenPacks.zenoss.DynamicView"
             file="dynamicview.zcml" />


    <!-- Impact Adapters

    Impact adapters are much like the Dynamic View adapters above in that they
    define relationships between objects. However, they are specifically for
    controlling the "Zenoss Datacenter Impact" product and can be simpler to
    configure because visualization is built-in and you only need to concern
    yourself with defining edges (or relationships) between objects.

    IRelationshipDataProvider works much like the Dynamic View
    IRelationsProvider above. It defines dependency relationships between
    objects.

    IStateProvider providers allow you to change how state is calculated for
    certain types of objects. Normally only the events impacting an object are
    used to calculate its state. IStateProvider allows you to bring in
    information from other sources such as the model.

    INodeTrigger providers allow you to define what triggers should be
    configured for certain types of objects automatically. A good example of
    where you'd use this is for port-channel interfaces. You'd likely want to
    create impact edges to all of the member interfaces and setup a redundancy
    policy on the port-channel.

    <configure zcml:condition="installed ZenPacks.zenoss.Impact">
        <include package="ZenPacks.zenoss.Impact" file="meta.zcml"/>


        <subscriber
            provides="ZenPacks.zenoss.Impact.impactd.interfaces.INodeTriggers"
            for="ZenPacks.zenoss.Liberator.GenericComponent.GenericComponent"
            factory=".impact.OVirtDatacenterTriggers"
            />

        <subscriber
            provides="ZenPacks.zenoss.Impact.impactd.interfaces.INodeTriggers"
            for="ZenPacks.zenoss.Liberator.GenericComponent.GenericComponent"
            factory=".impact.OVirtClusterTriggers"
            />

    </configure>
    -->


    <!-- Analytics Adapters

    The analytics subscribers and adapters are used to control the ETL
    (extract, transform and load) process from Zenoss into the data warehouse
    of the Zenoss Analytics product. It is recommended to enclose all analytics
    adapters in a conditional block because Analytics may or may not be
    installed.

    See analytics.py for the subscriber implementations.

    <configure zcml:condition="installed ZenPacks.zenoss.ZenETL">
        <adapter
            provides="Products.Zuul.interfaces.IReportable"
            for=".ExampleComponent.ExampleComponent"
            factory=".analytics.ExampleComponentReportable"
            />

    </configure>
    -->

    <!--  Include Liberator protocol helpers -->
    <include package=".componenttypes"/>

  <!-- defines the direct router directive -->
  <include package="Products.ZenUtils.extdirect.zope" file="meta.zcml"/>

  <!-- Define the router/facade for this zenpack -->
  <browser:directRouter
      name="ovirt_router"
      for="*"
      class=".router.OVirtRouter"
      namespace="Zenoss.remote"
      permission="zenoss.Common"
      />

  <adapter factory=".facade.OVirtFacade"
           provides=".interfaces.IOVirtFacade"
           name="ovirt"
           for="*"
           />

  <!-- Define the device loader -->
    <utility component=".ovirtloader.OVirtLoader"
             name="ovirt"
             provides="Products.ZenModel.interfaces.IDeviceLoader"
             />

</configure>

